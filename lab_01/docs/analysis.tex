\chapter{Аналитическая часть}

В данном разделе будет представлено теоретическое описание алгоритмов поиска расстояний Левенштейна и Дамерау-Левенштейна.

\section{Матричный алгоритм поиска расстояния Левенштейна}

Рассмотрим перевод строки $A'= A[:i]$ в строку $B' = B[:j]$, последние символы которых соответственно $a_{i-1}$ и $b_{j-1}$, при помощи следующих операций, каждая из которых имеет свою стоимость ($x$, $y$ - символы, $\lambda$ - строка):

\begin{itemize}
	\item вставка символа в произвольное место - $I$, стоимостью $w(x,\lambda)=1$;
	\item удаление символа с произвольной позиции - $D$, $w(\lambda,y)=1$;
	\item замена символа на другой - $R$, $w(x,y)=1, \medspace x \neq y$.
\end{itemize}

Расстояние Левенштейна --- минимальное количество операций $I$, $D$, $R$ для перевода $A'= A[:i]$ в $B' = B[:j]$ \cite{levenshtein}. Его можно подсчитать по следующей реккурентной формуле:

\begin{equation}
	\label{eq:rL}
	D(i, j) = \begin{cases}
		0 &\text{i = 0, j = 0}\\
		i &\text{j = 0, i > 0}\\
		j &\text{i = 0, j > 0}\\
		\min \lbrace \\
		\qquad D(i, j-1) + 1\\
		\qquad D(i-1, j) + 1 &\text{i > 0, j > 0}\\
		\qquad D(i-1, j-1) + m(a_{i-1}, b_{j-1})
		\rbrace
	\end{cases}
\end{equation}

Функция m определена как:
\begin{equation}
	\label{eq:rm}
	m(x, y) = \begin{cases}
		0 &\text{если x = y}\\
		1 &\text{иначе}
	\end{cases}
\end{equation}

Прямая реализация формулы 1.1 может быть малоэффективна по времени исполнения при больших i, j, т. к. множество промежуточных значений D(i, j) вычисляются заново множество раз подряд. Для оптимизации нахождения расстояния Левенштейна можно использовать матрицу в целях хранения соответствующих промежуточных значений (выполнять меморизацию промежуточных значений).

Матрицу $M$ размером $N+1$ и $L+1$, где $N$ и $L$ --- длины строк $A'= A[:i]$ и $B' = B[:j]$, заполняют по следующей формуле:

\begin{equation}
	\label{eq:mL}
	M[i][j] = \begin{cases}
		0 &\text{i = 0, j = 0}\\
		i &\text{j = 0, i > 0}\\
		j &\text{i = 0, j > 0}\\
		\min \lbrace \\
		\qquad M[i][j-1] + 1\\
		\qquad M[i-1][j] + 1\\
		\qquad M[i-1][j-1] + m(A[:i-1], B[:j-1]) \\
		\rbrace
	\end{cases}
\end{equation}

Функция m определена как:
\begin{equation}
	\label{eq:mm}
	m(x, y) = \begin{cases}
		0 &\text{если x = y}\\
		1 &\text{иначе}
	\end{cases}
\end{equation}

$M[N][L]$ содержит значение расстояния Левенштейна.

\section{Рекурсивный алгоритм поиска расстояния Дамерау-Левенштейна}

Как было сказано раннее, алгоритм Дамерау-Левенштейна отличается от алгоритма Левенштейна добавлением операции транспозиции символов при переводе одной строки в другую. Расстояние Дамерау-Левенштейна может быть найдено по формуле:

\begin{equation}
	\label{eq:DL}
	d(i, j) = \begin{cases}
		\max(i, j), &\text{если }\min(i, j) = 0,\\
		\min \lbrace \\
			\qquad d(i, j-1) + 1,\\
			\qquad d(i-1, j) + 1,\\
			\qquad d(i-1, j-1) + m(a_{i-1}, b_{j-1}), &\text{иначе}\\
			\qquad \left[ \begin{array}{cc}d(i-2, j-2) + 1, &\text{если }i,j > 1;\\
			\qquad &\text{}a_{i} = b_{j-1}; \\
			\qquad &\text{}b_{j} = a_{i-1}\\
			\qquad \infty, & \text{иначе}\end{array}\right.\\
		\rbrace
		\end{cases}
\end{equation}

Пусть $d(i,j)$ --- есть расстояние Дамерау-Левенштейна между строками $A'= A[:i]$ и $B' = B[:j]$. $B' = B[:j]$ может быть получен из $A'= A[:i]$ следующими способами:

\begin{itemize}
	\item если символ $a_{i-1}$ был удален при редактировании, тогда необходимо $A[:i-1]$ превратить в $B[:j]$, на что необходимо $d(i-1,j)$ операций редактирования. В этом случае $d(i,j) = d(i-1,j) + 1$;
	\item если символ $a_{j-1}$ был добавлен при редактировании, то необходимо $A[:i]$ превратить в $B[:j-1]$, на что необходимо $d(i,j-1)$ операций редактирования. В этом случае $d(i,j) = d(i,j-1) + 1$;
	\item если последние символы префиксов совпадают, т. е. $a_{i-1} = b_{j-1}$, то в этом случае можно не менять эти последние символы. Тогда $d(i,j) = d(i-1,j-1)$;
	\item если $\medspace a_{i-1} \neq b_{j-1}$, то тогда можно потратить 1 операцию на замену символа $a_{i-1}$ на $b_{j-1}$ и также потратить  операцию $D(i-1,j-1)$ на превращение $A[:i-1]$ в $B[:j-1]$. Тогда $d(i,j) = d(i-1,j-1) + 1$;
	\item eсли последние два символа $a_{i}$ и $b_{j}$ были переставлены, то $d(i,j)$ может быть равно $d(i-2,j-2) + 1$.
\end{itemize}

Далее при вычислении  необходимо взять минимум из всех перечисленных возможностей (при этом из случаев 3 или 4 рассматривается только один, в зависимости от условия $a_{i-1} = b_{j-1}$).

Начальные значения: $D(i,0) = i$, $D(0,j) = j$.

\section{Матричный алгоритм поиска расстояния Дамерау-Левенштейна}

Прямая реализация формулы 1.5 так же может быть малоэффективна по времени исполнения при больших i, j, т. к. множество промежуточных значений D(i, j) вычисляются заново множество раз подряд. Для оптимизации можно использовать матрицу в целях хранения соответствующих промежуточных значений.

Матрицу $M$ размером $N+1$ и $L+1$, где $N$ и $L$ --- длины строк $A'= A[:i]$ и $B' = B[:j]$, заполняют по следующей формуле:

\begin{equation}
	\label{eq:mL}
	M[i][j] = \begin{cases}
		0 &\text{i = 0, j = 0}\\
		i &\text{j = 0, i > 0}\\
		j &\text{i = 0, j > 0}\\
		\min
		\begin{cases}
		M[i][j-1] + 1\\
		M[i-1][j] + 1\\
		M[i-1][j-1] + m(A[:i-1], B[:j-1])\\
		\left[ \begin{array}{cc}M[i-2][j-2] + 1, &\text{если }i,j > 1;\\
			&\text{}a_{i-1} = b_{j-2}; \\
			&\text{}b_{j-1} = a_{i-2}\\
			\infty, & \text{иначе}\end{array}\right.\\
		\end{cases}
	\end{cases}
\end{equation}

$M[N][L]$ содержит значение расстояния Левенштейна.

\section{Рекурсивный алгоритм поиска расстояния Дамерау-Левенштейна с кешем}

Проблему повторяющихся вычислений можно решить и при использовании рекурсии. Для этого достаточно создать кеш в виде матрицы, где будут храниться уже вычисленные значения. Если при выполении рекурсии происходит вызов с теми данными, которые ещё не были обработаны, то необходимое значение вычисляется и заносится в соответствующую ячейку матрицы. Если же данные уже были обработаны
в дальнейших вычислениях участвует значение из матрицы. Таким образом,
повторных вычислений не происходит.

\section*{Вывод}

В данном разделе были описаны алгоритмы поиска расстояний Левенштейна и Дамерау-Левенштейна. Алгоритмы могут быть реализованы рекурсивно или итерационно.